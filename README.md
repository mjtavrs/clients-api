# 👤 Clients API

RESTful API created using Spring Boot for the management of a client database of a fictitious company. It allows the user to create, list (with or without filters), update and delete clients. It also has personalized exceptions treatment.

## ⚙️ Technologies used

- **Programming Language:** Java
- **Framework:** Spring Boot
- **Database:** PostgreSQL
- **ORM:** Spring Data JPA
- **Validation:** Bean Validation
- **Build tool:** Maven
- Lombok

## 🗂️ Project folder structure

Given that this is the first real API challenge that I created, I tried using the Clean Architecture design. The folder structure is this:

```txt
client_api/
├── Application.java
│
├── application/
│   └── useCases/
│       ├── CreateClient.java
│       ├── DeleteClient.java
│       ├── ListClients.java
│       └── UpdateClient.java
│
├── domain/
│   ├── exceptions/
│   │   ├── ClientNotFoundException.java
│   │   ├── NoClientsInDatabaseException.java
│   │   └── GlobalExceptionHandler.java
│   ├── model/
│   │   └── Client.java
│   └── repository/
│       └── ClientRepository.java
│
├── infrastructure/
│   └── specification/
│       └── ClientSpecification.java
│
└── interfaces/
    ├── controllers/
    │   └── ClientController.java
    └── dtos/
        ├── ClientFilterRequest.java
        ├── ClientResponse.java
        └── ClientUpdateRequest.java

```

## 📜 Dependencies (`pom.xml`)

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

## 🏃 How to run this project

First, you must clone the API. Use the following command:

```bash
  git clone https://github.com/mjtavrs/clients-api
```

Enter the project directory:

```bash
  cd clients-api
```

If you don't have PostgreSQL installed on your machine and prefer not to use Docker, you can download PostgreSQL [here](https://www.postgresql.org/download/) and install in your OS.

You might need to create a database if you haven't done it yet. In your **cmd** you can run:

```bash
psql -U postgres
```

Then, enter your password and create the database with the name you desire. Like this:

```sql
CREATE DATABASE name_of_database;
```

After that, leave using **\q**.

Make sure PostgreSQL is running on your machine or that you have a Docker container running. Now, you have to edit the `application.properties` to your use. By default, it comes like this:

```properties
spring.application.name=clients-api
spring.datasource.url=jdbc:postgresql://localhost:5432/clients
spring.datasource.username=admin
spring.datasource.password=admin
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
```

Remember to adapt `spring.datasource.url=jdbc:postgresql://localhost:5432/clients` to the port that PostgreSQL is using and to change the endpoint to the database name you created before.

After making all the changes, run the following command:

```bash
  mvn clean install
```

Now, just execute the project. If you're using an IDE like **IntelliJ IDEA** or **VSCode**, you can jump to the `Application.java` class and hit the run button, or, if you want, you can use:

```bash
  mvn spring-boot:run
```

## 🧩 The Client Entity

The `Client` entity represents the data model used in this API. It's mapped to the `client` table in your database and holds the following attributes:

| Field       | Type           | Required  | Observations                                                                               |
| ----------- | -------------- | --------- | ------------------------------------------------------------------------------------------ |
| `id`        | UUID           | Yes       | Automatically generated by the database.                                                   |
| `name`      | String         | Yes       | Cannot be null or blank (`@NotBlank`).                                                     |
| `cpf`       | String         | Yes       | Must be unique (`@Column(unique = true)`), used as a tax ID (Brazilian equivalent of SSN). |
| `email`     | String (email) | Yes       | Must be valid (`@Email`) and cannot be blank.                                              |
| `phone`     | String         | Yes       | Required field, validated with `@NotBlank`.                                                |
| `createdAt` | LocalDateTime  | Automatic | Automatically filled with `@CreationTimestamp`.                                            |
| `updatedAt` | LocalDateTime  | Automatic | Automatically updated with `@UpdateTimestamp`.                                             |

### 🚨 Validations

- `@NotBlank` in `name`, `email` and `phone`
- `@Email` in `email`
- `@Column(unique = true)` in `cpf`

### ⚠️ Remarks

- The `createdAt` and `updatedAt` fields use the Hibernate annotations (`@CreationTimestamp` and `@UpdateTimestamp`) for automatic timestamp management.
- The constructor with the `name`, `email` and `phone` arguments internally used to create objects in the API flow.

## 📦 Endpoints

### 🆕 Create a new Client

- Method: `POST`
- Route: `/clients`
- Register a new client with the given information in the request body.

```json
{
  "name": "Jane Doe",
  "cpf": "12345678900",
  "email": "janedoe@gmail.com",
  "phone": "0022223333"
}
```

That will give the following response with a `200 OK` status:

```json
{
  "id": "UUID",
  "name": "Jane Doe",
  "cpf": "12345678900",
  "email": "janedoe@email.com",
  "phone": "0022223333",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

### 📋 List the Clients

- Method: `GET`
- Routes: `/clients`, `/clients?name=`, `/clients?phone=` and `/clients?email=` or any combination of them.
- Returns all registered clients or applies filters by name, phone or e-mail. The filters are applied via `query params`.

If you run `/clients` or `/clients?name=Jane`, you'll get the `200 OK` status as a result and:

```json
[
  {
    "id": "UUID",
    "name": "Jane Doe",
    "email": "janedoe@email.com",
    "phone": "0022223333",
    "createdAt": "timestamp",
    "updatedAt": "timestamp"
  }
]
```

If there are no clients yet registered in your database, you'll get a `404 NOT_FOUND` status and the message `No clients found in the database.` in the body. This message comes from the `NoClientsInDatabaseException`.

### ♻️ Update a Client

- Method: `PUT`
- Route: `/clients/{id}`
- Updates the name, e-mail or phone of an existent client.

In the request body, you can change whichever you want or all of them, like this:

```json
{
  "email": "janedoe.2@gmail.com",
  "phone": "0033334444"
}
```

If everything goes fine, you'll get a `200 OK` status. If the given ID is not found, you'll get a `404 NOT_FOUND` with the message `Client not found.` in the response body.

### 🗑️ Delete a Client

- Method: `DELETE`
- Route: `/clients/{id}`
- Deletes a client from the database.

Again, if successful, you'll get a `200 OK` status with the message `Client successfully deleted`. No surprise, if you give an inexistent ID, you'll get a `404 NOT_FOUND` with the message `Client not found.` in the response body.

Both the **Update** and **Delete** services use the `ClientNotFoundException`.

## 🔜 Future improvements

Soon, this API will be improved with the following functionalities:

- 🔐 **Authentication and Security**
  - Implement Spring Security to protect the endpoints.
  - Add JWT authentication, allowing safe and token-based access.
- 📘 **Interactive documentation**
  - Integration with Swagger/OpenAPI to generate interactive and visual documentation to the endpoints.
- ⚠️ **Error standardization**
  - Creation of new personalized exceptions to cover different error scenarios (ex.: data validation, duplicated CPF, etc).
  - Centralization and standardization of error responses to facilitate API consumption by frontends or other applications.
- 🧪 **Automated tests**
  - Implement unit and integration tests to the API endpoints using the `spring-boot-starter-test`.
  - Tests covering all main flows, including success and failure cases.

## ✏️ Author

- [@mjtavrs](https://www.github.com/mjtavrs)

## ⚖️ License

This API uses the [MIT](https://choosealicense.com/licenses/mit/) license, which allows commerical use, distribution, modification and private use.
